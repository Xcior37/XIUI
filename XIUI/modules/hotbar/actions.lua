--[[
* XIUI Hotbar - Actions Module
]]--

require('common');
local ffi = require('ffi');
local d3d8 = require('d3d8');
local data = require('modules.hotbar.data');
local horizonSpells = require('modules.hotbar.database.horizonspells');
local textures = require('modules.hotbar.textures');

local M = {};

-- ============================================
-- Modifier Key Tracking (Event-based)
-- ============================================
-- Track modifier states via keyboard events.
-- This is reset on focus loss which prevents "stuck" keys.

local modifierCtrl = false;
local modifierAlt = false;
local modifierShift = false;

--- Update modifier states from keyboard events
--- Called from HandleKey for every key event
local function UpdateModifierStates(keyCode, isRelease)
    -- Ctrl keys (17 = generic, 162 = left, 163 = right)
    if keyCode == 17 or keyCode == 162 or keyCode == 163 then
        modifierCtrl = not isRelease;
    -- Alt keys (18 = generic, 164 = left, 165 = right)
    elseif keyCode == 18 or keyCode == 164 or keyCode == 165 then
        modifierAlt = not isRelease;
    -- Shift keys (16 = generic, 160 = left, 161 = right)
    elseif keyCode == 16 or keyCode == 160 or keyCode == 161 then
        modifierShift = not isRelease;
    end
end

--- Get current modifier states
local function GetModifierStates()
    return modifierCtrl, modifierAlt, modifierShift;
end

--- Reset all modifier states (call on focus loss or zone)
function M.ResetModifierStates()
    modifierCtrl = false;
    modifierAlt = false;
    modifierShift = false;
end

-- Cache for custom icons loaded from disk
local customIconCache = {};

-- Mapping from summoning spell names to texture cache keys
-- Spell names (as they appear in-game) -> texture key (as loaded in textures.lua)
local summonSpellToIconKey = {
    -- Avatars
    ['Carbuncle'] = 'summon_Carbuncle',
    ['Ifrit'] = 'summon_Ifrit',
    ['Shiva'] = 'summon_Shiva',
    ['Garuda'] = 'summon_Garuda',
    ['Titan'] = 'summon_Titan',
    ['Ramuh'] = 'summon_Ramuh',
    ['Leviathan'] = 'summon_Leviathan',
    ['Fenrir'] = 'summon_Fenrir',
    ['Diabolos'] = 'summon_Diabolos',
    ['Cait Sith'] = 'summon_CaitSith',
    ['Alexander'] = 'summon_Alexander',
    ['Odin'] = 'summon_Odin',
    ['Atomos'] = 'summon_Atomos',
    ['Siren'] = 'summon_Siren',
    -- Spirits
    ['Fire Spirit'] = 'summon_FireSpirit',
    ['Ice Spirit'] = 'summon_IceSpirit',
    ['Air Spirit'] = 'summon_AirSpirit',
    ['Earth Spirit'] = 'summon_EarthSpirit',
    ['Thunder Spirit'] = 'summon_ThunderSpirit',
    ['Water Spirit'] = 'summon_WaterSpirit',
    ['Light Spirit'] = 'summon_LightSpirit',
    ['Dark Spirit'] = 'summon_DarkSpirit',
};

-- Mapping from pet command names to texture cache keys
local petCommandToIconKey = {
    ['Assault'] = 'ability_Assault',
    ['Release'] = 'ability_Release',
    ['Retreat'] = 'ability_Retreat',
};

-- Mapping from SMN job ability names to texture cache keys
local smnAbilityToIconKey = {
    ['Apogee'] = 'ability_Apogee',
    ['Astral Conduit'] = 'ability_AstralConduit',
    ['Astral Flow'] = 'ability_AstralFlow',
    ["Avatar's Favor"] = 'ability_AvatarsFavor',
    ['Elemental Siphon'] = 'ability_ElementalSiphon',
    ['Mana Cede'] = 'ability_ManaCede',
};

-- Mapping from Trust names to texture cache keys
local trustToIconKey = {
    ['Ajido-Marujido'] = 'trust_ajido-marujido',
    ['Amchuchu'] = 'trust_amchuchu',
    ['Ayame'] = 'trust_ayame',
    ['Cid'] = 'trust_cid',
    ['Curilla'] = 'trust_curilla',
    ['Darrcuiln'] = 'trust_darrcuiln',
    ['Excenmille'] = 'trust_excenmille',
    ['Halver'] = 'trust_halver',
    ['Iron Eater'] = 'trust_iron-eater',
    ['Joachim'] = 'trust_joachim',
    ['King of Hearts'] = 'trust_king-of-hearts',
    ['Koru-Moru'] = 'trust_koru-moru',
    ['Kupipi'] = 'trust_kupipi',
    ['Kuyin Hathdenna'] = 'trust_kuyin-hathdenna',
    ['Lion'] = 'trust_lion',
    ['Makki-Chebukki'] = 'trust_makki-chebukki',
    ['Mildaurion'] = 'trust_mildaurion',
    ['Mnejing'] = 'trust_mnejing',
    ['Morimar'] = 'trust_morimar',
    ['Naja Salaheem'] = 'trust_naja',
    ['Naji'] = 'trust_naji',
    ['Nanaa Mihgo'] = 'trust_nanaa-mihgo',
    ['Ovjang'] = 'trust_ovjang',
    ['Prishe'] = 'trust_prishe',
    ['Qultada'] = 'trust_qultada',
    ['Rahal'] = 'trust_rahal',
    ['Rongelouts'] = 'trust_rongelouts',
    ['Rughadjeen'] = 'trust_rughadjeen',
    ['Sakura'] = 'trust_sakura',
    ['Semih Lafihna'] = 'trust_semih-lafihna',
    ['Shantotto'] = 'trust_shantotto',
    ['Shantotto II'] = 'trust_shantotto-II',
    ['Star Sibyl'] = 'trust_star-sibyl',
    ['Tenzen'] = 'trust_tenzen',
    ['Trion'] = 'trust_trion',
    ['Valaineral'] = 'trust_valaineral',
    ['Volker'] = 'trust_volker',
    ['Yoran-Oran'] = 'trust_yoran-oran',
    ['Zazarg'] = 'trust_zazarg',
    ['Zeid'] = 'trust_zeid',
    ['Zeid II'] = 'trust_zeid-II',
};

-- Mapping from Blue Magic spell names to texture cache keys
local blueMagicToIconKey = {
    ['Battle Dance'] = 'blue_battle_dance',
    ['Blank Gaze'] = 'blue_blank_gaze',
    ['Cocoon'] = 'blue_cocoon',
    ['Foot Kick'] = 'blue_foot_kick',
    ['Grand Slam'] = 'blue_grand_slam',
    ['Head Butt'] = 'blue_headbutt',
    ['Healing Breeze'] = 'blue_healing_breeze',
    ['Jet Stream'] = 'blue_jet_stream',
    ['Light of Penance'] = 'blue_light_of_penance',
    ['Magic Fruit'] = 'blue_magic_fruit',
    ['Metallic Body'] = 'blue_metallic_body',
    ['Power Attack'] = 'blue_power_attack',
    ['Sheep Song'] = 'blue_sheep_song',
    ['Terror Touch'] = 'blue_terror_touch',
    ['Uppercut'] = 'blue_uppercut',
    ['Wild Oats'] = 'blue_wild_oats',
    ['Zephyr Mantle'] = 'blue_zephyr_mantle',
};

-- Mapping from Mount names to texture cache keys
local mountToIconKey = {
    ['Beetle'] = 'mount_beetle',
    ['Bomb'] = 'mount_bomb',
    ['Chocobo'] = 'mount_chocobo',
    ['Crab'] = 'mount_crab',
    ['Crawler'] = 'mount_crawler',
    ['Fenrir'] = 'mount_fenrir',
    ['Magic Pot'] = 'mount_magic_pot',
    ['Moogle'] = 'mount_moogle',
    ['Morbol'] = 'mount_morbol',
    ['Raptor'] = 'mount_raptor',
    ['Red Crab'] = 'mount_red_crab',
    ['Sheep'] = 'mount_sheep',
    ['Tiger'] = 'mount_tiger',
    ['Tulfaire'] = 'mount_tulfaire',
    ['Warmachine'] = 'mount_warmachine',
};

-- Mapping from Rune Fencer abilities to texture cache keys
local runAbilityToIconKey = {
    -- Runes
    ['Ignis'] = 'rune_ignis',
    ['Gelus'] = 'rune_gelus',
    ['Flabra'] = 'rune_flabra',
    ['Tellus'] = 'rune_tellus',
    ['Sulpor'] = 'rune_sulpor',
    ['Unda'] = 'rune_unda',
    ['Lux'] = 'rune_lux',
    ['Tenebrae'] = 'rune_tenebrae',
    -- Abilities
    ['Battuta'] = 'ability_battuta',
    ['Gambit'] = 'ability_gambit',
    ['Liement'] = 'ability_liement',
    ['Pflug'] = 'ability_pflug',
    ['Rayke'] = 'ability_pulse',
    ['Foil'] = 'ability_foil',
};

-- Mapping from other job abilities to texture cache keys
local otherAbilityToIconKey = {
    -- DRG
    ['Jump'] = 'ability_jump',
    ['High Jump'] = 'ability_jump',
    ['Super Jump'] = 'ability_jump',
    -- RDM
    ['Chainspell'] = 'ability_chainspell',
    ['Stymie'] = 'ability_stymie',
    ['Convert'] = 'ability_2hr',
    -- BLM
    ['Elemental Seal'] = 'ability_2hr',
};

-- Track currently pressed hotbar/slot for visual feedback
local currentPressedHotbar = nil;
local currentPressedSlot = nil;

-- Icon cache for items (keyed by item name since we look up by name)
local itemIconCache = {};

-- ============================================
-- Helper Functions
-- ============================================

--- Find a spell by English name in horizonspells
---@param spellName string The English name of the spell
---@return table|nil The spell data table with en, icon_id, prefix, and id fields
local function GetSpellByName(spellName)
    for _, spell in pairs(horizonSpells) do
        if spell.en == spellName then
            return spell;
        end
    end
    return nil;
end

--- Get MP cost for an action (only applicable to magic spells)
---@param bind table The keybind data with actionType and action fields
---@return number|nil mpCost The MP cost, or nil if not applicable
function M.GetMPCost(bind)
    if not bind then return nil; end
    if bind.actionType ~= 'ma' then return nil; end

    local spell = GetSpellByName(bind.action);
    if spell and spell.mp_cost and spell.mp_cost > 0 then
        return spell.mp_cost;
    end
    return nil;
end

--- Check if an action is currently available to use
--- Takes into account job, level, subjob, and level sync
---@param bind table The keybind data with actionType and action fields
---@return boolean isAvailable True if the action can be used
---@return string|nil reason Reason if not available (e.g., "Level 50 required", "Wrong job")
function M.IsActionAvailable(bind)
    if not bind then return true, nil; end

    local player = AshitaCore:GetMemoryManager():GetPlayer();
    if not player then return true, nil; end

    local mainJobId = player:GetMainJob();
    local mainJobLevel = player:GetMainJobLevel();
    local subJobId = player:GetSubJob();
    local subJobLevel = player:GetSubJobLevel();

    -- Handle magic spells
    if bind.actionType == 'ma' then
        local spell = GetSpellByName(bind.action);
        if not spell then return true, nil; end  -- Unknown spell, assume available

        local levels = spell.levels;
        if not levels then return true, nil; end  -- No level requirements

        -- Check if main job can cast this spell
        local mainReqLevel = levels[mainJobId];
        local subReqLevel = subJobId and levels[subJobId] or nil;

        -- Check main job first
        if mainReqLevel then
            if mainJobLevel >= mainReqLevel then
                return true, nil;  -- Can cast with main job
            end
        end

        -- Check subjob
        if subReqLevel then
            if subJobLevel >= subReqLevel then
                return true, nil;  -- Can cast with subjob
            end
        end

        -- Spell exists but can't be cast
        if mainReqLevel then
            -- Has the job but not the level
            return false, string.format("Lv%d", mainReqLevel);
        elseif subReqLevel then
            -- Subjob has it but not the level
            return false, string.format("Lv%d", subReqLevel);
        else
            -- Job can't cast this spell at all
            return false, "Job";
        end

    -- Handle job abilities
    elseif bind.actionType == 'ja' then
        -- Check if player has this ability
        local hasAbility = false;
        local resMgr = AshitaCore:GetResourceManager();
        if resMgr then
            for abilityId = 1, 1024 do
                if player:HasAbility(abilityId) then
                    local ability = resMgr:GetAbilityById(abilityId);
                    if ability and ability.Name and ability.Name[1] == bind.action then
                        hasAbility = true;
                        break;
                    end
                end
            end
        end
        if not hasAbility then
            return false, "N/A";
        end

    -- Handle weapon skills
    elseif bind.actionType == 'ws' then
        -- Check if player has this weapon skill
        local hasWS = false;
        local resMgr = AshitaCore:GetResourceManager();
        if resMgr then
            for abilityId = 1, 1024 do
                if player:HasAbility(abilityId) then
                    local ability = resMgr:GetAbilityById(abilityId);
                    if ability and ability.Name and ability.Name[1] == bind.action then
                        -- Verify it's a weapon skill (Type 3)
                        local abilityType = ability.Type and bit.band(ability.Type, 7) or 0;
                        if abilityType == 3 then
                            hasWS = true;
                            break;
                        end
                    end
                end
            end
        end
        if not hasWS then
            return false, "N/A";
        end
    end

    return true, nil;
end

--- Load item icon from game resources by item ID
--- Uses file cache for primitive rendering compatibility
---@param itemId number The item ID
---@return table|nil texture The icon texture with path field for primitive rendering
local function LoadItemIconById(itemId)
    if not itemId or itemId == 0 or itemId == 65535 then
        return nil;
    end

    -- Check cache first - only use if it has a path (for primitive rendering)
    -- If cached without path, try to reload in case PNG is now available
    if itemIconCache[itemId] and itemIconCache[itemId].path then
        return itemIconCache[itemId];
    end

    -- Try to load via file cache (enables primitive rendering)
    local texture = textures:LoadItemIcon(itemId);
    if texture then
        itemIconCache[itemId] = texture;
        return texture;
    end

    -- Fallback to memory loading (no path field, uses ImGui rendering)
    local success, result = pcall(function()
        local device = GetD3D8Device();
        if device == nil then return nil; end

        local resMgr = AshitaCore:GetResourceManager();
        if not resMgr then return nil; end

        local item = resMgr:GetItemById(itemId);
        if item == nil then return nil; end

        if item.Bitmap == nil or item.ImageSize == nil or item.ImageSize <= 0 then
            return nil;
        end

        local dx_texture_ptr = ffi.new('IDirect3DTexture8*[1]');
        if ffi.C.D3DXCreateTextureFromFileInMemoryEx(
            device, item.Bitmap, item.ImageSize,
            0xFFFFFFFF, 0xFFFFFFFF, 1, 0,
            ffi.C.D3DFMT_A8R8G8B8, ffi.C.D3DPOOL_MANAGED,
            ffi.C.D3DX_DEFAULT, ffi.C.D3DX_DEFAULT,
            0xFF000000, nil, nil, dx_texture_ptr
        ) == ffi.C.S_OK then
            return {
                image = d3d8.gc_safe_release(ffi.cast('IDirect3DTexture8*', dx_texture_ptr[0])),
                width = 32,  -- FFXI item icons are 32x32
                height = 32,
                -- Note: No 'path' field, will use ImGui fallback in slotrenderer
            };
        end
        return nil;
    end);

    if success and result then
        itemIconCache[itemId] = result;
    end

    return itemIconCache[itemId];
end

-- Cache for item name -> id lookups (populated lazily)
local itemNameToIdCache = {};

--- Load item icon from game resources by item name (slower, uses name lookup)
---@param itemName string The item name to look up
---@return table|nil texture The icon texture
local function LoadItemIconByName(itemName)
    if not itemName or itemName == '' then
        return nil;
    end

    -- Check name->id cache first
    if itemNameToIdCache[itemName] then
        return LoadItemIconById(itemNameToIdCache[itemName]);
    end

    -- Search for item by name (slow, but cached after first find)
    local resMgr = AshitaCore:GetResourceManager();
    if not resMgr then return nil; end

    for itemId = 1, 65535 do
        local item = resMgr:GetItemById(itemId);
        if item and item.Name and item.Name[1] == itemName then
            itemNameToIdCache[itemName] = itemId;
            return LoadItemIconById(itemId);
        end
    end

    return nil;
end

--- Get icon for a bind (separate from command building for use in drag preview)
---@param bind table The keybind data
---@return any|nil icon The icon texture (if available)
---@return number|nil iconId The icon ID (for reference)
function M.GetBindIcon(bind)
    if not bind then
        return nil, nil;
    end

    local icon = nil;
    local iconId = nil;

    -- Check if this slot references a macro - if so, get the macro's current icon
    -- This enables live updates when macro icons are changed in the palette
    if bind.macroRef and gConfig and gConfig.macroDB then
        -- Use stored palette key if available, otherwise fall back to job ID
        local paletteKey = bind.macroPaletteKey or data.jobId or 1;
        local macroDB = gConfig.macroDB[paletteKey];
        if macroDB then
            for _, macro in ipairs(macroDB) do
                if macro.id == bind.macroRef then
                    -- Found the source macro - use its current custom icon if set
                    if macro.customIconType then
                        if macro.customIconType == 'spell' and macro.customIconId then
                            icon = textures:Get('spells' .. string.format('%05d', macro.customIconId));
                            iconId = macro.customIconId;
                            if icon then return icon, iconId; end
                        elseif macro.customIconType == 'item' and macro.customIconId then
                            icon = LoadItemIconById(macro.customIconId);
                            iconId = macro.customIconId;
                            if icon then return icon, iconId; end
                        elseif macro.customIconType == 'custom' and macro.customIconPath then
                            -- Check cache first
                            if customIconCache[macro.customIconPath] then
                                return customIconCache[macro.customIconPath], nil;
                            end
                            local customDir = string.format('%saddons\\XIUI\\assets\\hotbar\\custom\\', AshitaCore:GetInstallPath());
                            icon = textures:LoadTextureFromPath(customDir .. macro.customIconPath);
                            if icon then
                                customIconCache[macro.customIconPath] = icon;
                                return icon, nil;
                            end
                        end
                    end
                    break;
                end
            end
        end
    end

    -- Check for custom icon override on the bind itself
    if bind.customIconType then
        if bind.customIconType == 'spell' and bind.customIconId then
            icon = textures:Get('spells' .. string.format('%05d', bind.customIconId));
            iconId = bind.customIconId;
            if icon then return icon, iconId; end
        elseif bind.customIconType == 'item' and bind.customIconId then
            icon = LoadItemIconById(bind.customIconId);
            iconId = bind.customIconId;
            if icon then return icon, iconId; end
        elseif bind.customIconType == 'custom' and bind.customIconPath then
            -- Check cache first
            if customIconCache[bind.customIconPath] then
                return customIconCache[bind.customIconPath], nil;
            end
            -- Load custom icon from assets/hotbar/custom/ directory
            local customDir = string.format('%saddons\\XIUI\\assets\\hotbar\\custom\\', AshitaCore:GetInstallPath());
            icon = textures:LoadTextureFromPath(customDir .. bind.customIconPath);
            if icon then
                customIconCache[bind.customIconPath] = icon;
                return icon, nil;
            end
        end
    end

    if bind.actionType == 'ma' then
        -- Check for summoning magic first (custom icons)
        local summonIconKey = summonSpellToIconKey[bind.action];
        if summonIconKey then
            icon = textures:Get(summonIconKey);
            if icon then
                local spell = GetSpellByName(bind.action);
                if spell then iconId = spell.id; end
                return icon, iconId;
            end
        end
        -- Check for Trust icons
        local trustIconKey = trustToIconKey[bind.action];
        if trustIconKey then
            icon = textures:Get(trustIconKey);
            if icon then
                local spell = GetSpellByName(bind.action);
                if spell then iconId = spell.id; end
                return icon, iconId;
            end
        end
        -- Check for Blue Magic icons
        local blueIconKey = blueMagicToIconKey[bind.action];
        if blueIconKey then
            icon = textures:Get(blueIconKey);
            if icon then
                local spell = GetSpellByName(bind.action);
                if spell then iconId = spell.id; end
                return icon, iconId;
            end
        end
        -- Magic spell - look up in horizonspells database
        local spell = GetSpellByName(bind.action);
        if spell then
            iconId = spell.id;
            icon = textures:Get('spells' .. string.format('%05d', spell.id));
        end
    elseif bind.actionType == 'ja' then
        -- Check for SMN ability icons first
        local smnIconKey = smnAbilityToIconKey[bind.action];
        if smnIconKey then
            icon = textures:Get(smnIconKey);
            if icon then return icon, iconId; end
        end
        -- Check for RUN ability icons
        local runIconKey = runAbilityToIconKey[bind.action];
        if runIconKey then
            icon = textures:Get(runIconKey);
            if icon then return icon, iconId; end
        end
        -- Check for other job ability icons
        local otherIconKey = otherAbilityToIconKey[bind.action];
        if otherIconKey then
            icon = textures:Get(otherIconKey);
            if icon then return icon, iconId; end
        end
        -- Job ability - try to get from game resources
        local resMgr = AshitaCore:GetResourceManager();
        if resMgr then
            for abilityId = 1, 1024 do
                local ability = resMgr:GetAbilityById(abilityId);
                if ability and ability.Name and ability.Name[1] == bind.action then
                    iconId = abilityId;
                    break;
                end
            end
        end
    elseif bind.actionType == 'pet' then
        -- Check for pet command icons first
        local petIconKey = petCommandToIconKey[bind.action];
        if petIconKey then
            icon = textures:Get(petIconKey);
            if icon then
                return icon, iconId;
            end
        end
    elseif bind.actionType == 'ws' then
        -- Weaponskill - try to get from game resources
        local resMgr = AshitaCore:GetResourceManager();
        if resMgr then
            for wsId = 1, 255 do
                local ability = resMgr:GetAbilityById(wsId + 256);
                if ability and ability.Name and ability.Name[1] == bind.action then
                    iconId = wsId;
                    break;
                end
            end
        end
    elseif bind.actionType == 'item' or bind.actionType == 'equip' then
        -- Item or Equipment - load icon from game resources
        -- Use itemId if available (faster), otherwise fall back to name lookup
        if bind.itemId then
            icon = LoadItemIconById(bind.itemId);
        else
            icon = LoadItemIconByName(bind.action);
        end
    end

    return icon, iconId;
end

--- Build command and icon from keybind data
--- Centralized function to avoid code duplication between display and key handling
---@param bind table The keybind data with actionType, action, and target fields
---@return string|nil command The command to execute
---@return any|nil icon The icon texture (if applicable)
function M.BuildCommand(bind)
    local command = nil;

    if not bind then
        return nil, nil;
    end

    -- Get icon using the helper function
    local icon = M.GetBindIcon(bind);

    -- Build command based on action type
    if bind.actionType == 'ma' then
        -- Magic spell
        command = '/ma "' .. bind.action .. '" <' .. bind.target .. '>';
    elseif bind.actionType == 'ja' then
        -- Job ability
        command = '/ja "' .. bind.action .. '" <' .. bind.target .. '>';
    elseif bind.actionType == 'ws' then
        -- Weapon skill
        command = '/ws "' .. bind.action .. '" <' .. bind.target .. '>';
    elseif bind.actionType == 'item' then
        -- Use item
        command = '/item "' .. bind.action .. '" <' .. bind.target .. '>';
    elseif bind.actionType == 'equip' then
        -- Equip item to slot
        local slot = bind.equipSlot or 'main';
        command = '/equip ' .. slot .. ' "' .. bind.action .. '"';
    elseif bind.actionType == 'pet' then
        -- Pet command
        command = '/pet "' .. bind.action .. '" <' .. bind.target .. '>';
    elseif bind.actionType == 'macro' then
        -- Macro command (raw command or use macroText)
        command = bind.macroText or bind.action;
    end

    return command, icon;
end



-- Parse lParam bits per Keystroke Message Flags:
-- bit 31 - transition state: 0 = key press, 1 = key release
local function parseKeyEventFlags(event)
   local lparam = tonumber(event.lparam) or 0
   local function getBit(val, idx) return math.floor(val / (2^idx)) % 2 end
   return (getBit(lparam, 31) == 1)
end

--- Execute a command string (handles multi-line macros with /wait support)
--- Splits by newlines and executes each non-empty line in sequence
--- Properly handles /wait, /pause, /sleep by using Ashita's task scheduler
--- @param commandText string The command text (may contain newlines)
--- @return boolean success Whether any command was executed
function M.ExecuteCommandString(commandText)
    if not commandText or commandText == '' then
        return false;
    end

    -- Collect all lines first
    local lines = {};
    for line in commandText:gmatch('[^\r\n]+') do
        -- Trim whitespace
        line = line:match('^%s*(.-)%s*$');
        if line and line ~= '' then
            table.insert(lines, line);
        end
    end

    if #lines == 0 then
        return false;
    end

    -- Recursive function to execute lines with proper /wait handling
    -- This chains tasks instead of scheduling them all at once
    local function executeNextLine(index)
        if index > #lines then
            return;
        end

        local line = lines[index];

        -- Check for wait/pause/sleep commands
        local waitMatch = line:match('^/wait%s*(%d*%.?%d*)') or
                          line:match('^/pause%s*(%d*%.?%d*)') or
                          line:match('^/sleep%s*(%d*%.?%d*)');

        if waitMatch then
            -- It's a wait command - schedule the next line after the delay
            local delay = tonumber(waitMatch) or 1;
            ashita.tasks.once(delay, function()
                executeNextLine(index + 1);
            end);
        else
            -- It's a regular command - execute it
            local chatManager = AshitaCore:GetChatManager();
            if chatManager then
                chatManager:QueueCommand(-1, line);
            end
            -- Continue to next line immediately
            executeNextLine(index + 1);
        end
    end

    -- Start executing from the first line
    executeNextLine(1);
    return true;
end

-- Handle a keybind with the given modifier state
function M.HandleKeybind(hotbar, slot)
    -- Use GetKeybindForSlot which checks both user slot actions AND default keybinds
    local bind = data.GetKeybindForSlot(hotbar, slot);
    if not bind then
        return false;
    end

    -- Build and execute command
    local command, _ = M.BuildCommand(bind);
    return M.ExecuteCommandString(command);
end

-- Find hotbar and slot that matches the pressed key + modifiers
local function FindMatchingKeybind(keyCode, ctrl, alt, shift)
    -- Search through all bars for a matching keybind
    for barIndex = 1, 6 do
        local configKey = 'hotbarBar' .. barIndex;
        local barSettings = gConfig and gConfig[configKey];
        if barSettings and barSettings.enabled and barSettings.keyBindings then
            for slotIndex, binding in pairs(barSettings.keyBindings) do
                if binding and binding.key == keyCode then
                    -- Check modifiers match
                    local ctrlMatch = (binding.ctrl or false) == (ctrl or false);
                    local altMatch = (binding.alt or false) == (alt or false);
                    local shiftMatch = (binding.shift or false) == (shift or false);
                    if ctrlMatch and altMatch and shiftMatch then
                        return barIndex, slotIndex;
                    end
                end
            end
        end
    end
    return nil, nil;
end

function M.HandleKey(event)
   --print("Key pressed wparam: " .. tostring(event.wparam) .. " lparam: " .. tostring(event.lparam));
   --https://learn.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes

   local isRelease = parseKeyEventFlags(event)
   local keyCode = event.wparam;

   -- Update modifier state tracking
   UpdateModifierStates(keyCode, isRelease);

   -- Get current modifier states
   local controlPressed, altPressed, shiftPressed = GetModifierStates();

   -- Skip main keyboard minus (VK 189) WITHOUT modifiers - conflicts with native FFXI menus
   -- Ctrl+- and Alt+- are allowed for hotbar binds
   if keyCode == 189 and not controlPressed and not altPressed and not shiftPressed then
       return;
   end

   -- Check if keybind editor is capturing input
   local hotbarConfig = require('config.hotbar');
   if hotbarConfig.IsCapturingKeybind() then
       if not isRelease then
           if hotbarConfig.HandleKeybindCapture(keyCode, controlPressed, altPressed, shiftPressed) then
               event.blocked = true;
           end
       end
       return;
   end

   -- Find matching keybind from custom key assignments
   local hotbar, slot = FindMatchingKeybind(keyCode, controlPressed, altPressed, shiftPressed);

   if hotbar and slot then
       if isRelease then
           -- Clear pressed state on release (only if it matches what was pressed)
           if currentPressedHotbar == hotbar and currentPressedSlot == slot then
               currentPressedHotbar = nil;
               currentPressedSlot = nil;
           end
       else
           -- Set pressed state and try to execute the keybind
           currentPressedHotbar = hotbar;
           currentPressedSlot = slot;
           if M.HandleKeybind(hotbar, slot) then
               event.blocked = true;
           end
       end
   elseif isRelease then
       -- Clear pressed state on any release when no match
       currentPressedHotbar = nil;
       currentPressedSlot = nil;
   end
end

-- Get currently pressed hotbar index (1-6) or nil
function M.GetPressedHotbar()
    return currentPressedHotbar;
end

-- Get currently pressed slot index (1-12) or nil
function M.GetPressedSlot()
    return currentPressedSlot;
end

--- Execute an action directly from slot data
--- Used by crossbar for controller input
---@param slotAction table The slot action with actionType, action, target, etc.
---@return boolean success Whether the action was executed
function M.ExecuteAction(slotAction)
    if not slotAction then return false; end
    if not slotAction.actionType or not slotAction.action then return false; end

    -- Build and execute command (handles multi-line macros)
    local command, _ = M.BuildCommand(slotAction);
    return M.ExecuteCommandString(command);
end

-- Clear the custom icon cache (call when icons may have changed)
function M.ClearCustomIconCache()
    customIconCache = {};
end

-- ============================================
-- Ashita Keybind Registration
-- Uses /bind to intercept keys at a lower level than addon keyboard events,
-- which properly blocks native FFXI macros from firing
-- ============================================

-- SAFETY: Set to false to completely disable /bind registration
-- This prevents native macro blocking but avoids potential crashes
local ENABLE_ASHITA_BINDS = true;

-- Track registered binds so we can unbind them on cleanup/change
local registeredBinds = {};

-- Track if silent mode is enabled
local silentModeEnabled = false;

-- Track if module is being cleaned up (prevents registration during unload)
local isCleaningUp = false;

-- Convert modifier flags + key code to Ashita bind format
-- Ashita uses: ^ for Ctrl, ! for Alt, + for Shift
local function FormatBindKey(keyCode, ctrl, alt, shift)
    local prefix = '';
    if ctrl then prefix = prefix .. '^'; end
    if alt then prefix = prefix .. '!'; end
    if shift then prefix = prefix .. '+'; end

    -- Convert virtual key code to Ashita key name
    -- Reference: https://wiki.ashitaxi.com/doku.php?id=ashitav3:keybinds
    local keyName = nil;

    -- Number keys 0-9 (VK 48-57)
    if keyCode >= 48 and keyCode <= 57 then
        keyName = tostring(keyCode - 48);
    -- Letter keys A-Z (VK 65-90)
    elseif keyCode >= 65 and keyCode <= 90 then
        keyName = string.char(keyCode);
    -- Function keys F1-F12 (VK 112-123)
    elseif keyCode >= 112 and keyCode <= 123 then
        keyName = 'F' .. tostring(keyCode - 111);
    -- Numpad 0-9 (VK 96-105)
    elseif keyCode >= 96 and keyCode <= 105 then
        keyName = 'NUMPAD' .. tostring(keyCode - 96);
    -- Main keyboard minus (VK 189) - only supported WITH modifiers (Ctrl/Alt/Shift)
    -- Bare minus conflicts with native FFXI menus, but modifier combos are fine
    elseif keyCode == 189 then
        -- Only allow if a modifier is present (checked via prefix)
        if ctrl or alt or shift then
            keyName = '-';
        end
    -- Numpad minus (VK 109)
    elseif keyCode == 109 then
        keyName = 'NUMPAD-';
    -- Main keyboard equals/plus (VK 187)
    elseif keyCode == 187 then
        keyName = '=';
    -- Numpad plus (VK 107)
    elseif keyCode == 107 then
        keyName = 'NUMPAD+';
    -- Numpad multiply (VK 106)
    elseif keyCode == 106 then
        keyName = 'NUMPAD*';
    -- Numpad divide (VK 111)
    elseif keyCode == 111 then
        keyName = 'NUMPAD/';
    -- Numpad decimal (VK 110)
    elseif keyCode == 110 then
        keyName = 'NUMPAD.';
    -- Space (VK 32)
    elseif keyCode == 32 then
        keyName = 'SPACE';
    -- Tab (VK 9)
    elseif keyCode == 9 then
        keyName = 'TAB';
    -- Escape (VK 27)
    elseif keyCode == 27 then
        keyName = 'ESCAPE';
    -- Backspace (VK 8)
    elseif keyCode == 8 then
        keyName = 'BACK';
    -- Enter (VK 13)
    elseif keyCode == 13 then
        keyName = 'RETURN';
    -- Backtick/tilde (VK 192)
    elseif keyCode == 192 then
        keyName = '`';
    -- [ (VK 219)
    elseif keyCode == 219 then
        keyName = '[';
    -- ] (VK 221)
    elseif keyCode == 221 then
        keyName = ']';
    -- \ (VK 220)
    elseif keyCode == 220 then
        keyName = '\\';
    -- ; (VK 186)
    elseif keyCode == 186 then
        keyName = ';';
    -- ' (VK 222)
    elseif keyCode == 222 then
        keyName = "'";
    -- , (VK 188)
    elseif keyCode == 188 then
        keyName = ',';
    -- . (VK 190)
    elseif keyCode == 190 then
        keyName = '.';
    -- / (VK 191)
    elseif keyCode == 191 then
        keyName = '/';
    end

    if not keyName then
        return nil;
    end

    return prefix .. keyName;
end

--- Register all configured keybinds with Ashita's /bind system
--- This blocks native FFXI macros from firing on those keys
function M.RegisterKeybinds()
    -- Safety checks
    if not ENABLE_ASHITA_BINDS then return; end
    if isCleaningUp then return; end

    -- Wrap everything in pcall for safety
    local ok, err = pcall(function()
        local chatManager = AshitaCore:GetChatManager();
        if not chatManager then return; end

        -- Enable silent mode once and leave it on permanently
        -- This avoids timing issues with async command queue
        if not silentModeEnabled then
            chatManager:QueueCommand(-1, '/bind silent 1');
            silentModeEnabled = true;

            -- Explicitly unbind bare minus key to clear any stale binds
            -- The minus key without modifiers conflicts with native FFXI menus
            -- Ctrl+- and Alt+- are allowed
            chatManager:QueueCommand(-1, '/unbind -');
        end

        -- Build list of new binds we want to register
        local newBinds = {};

        if gConfig then
            for barIndex = 1, 6 do
                local configKey = 'hotbarBar' .. barIndex;
                local barSettings = gConfig[configKey];

                if barSettings and barSettings.enabled and barSettings.keyBindings then
                    for slotIndex, binding in pairs(barSettings.keyBindings) do
                        if binding and binding.key then
                            local bindKey = FormatBindKey(
                                binding.key,
                                binding.ctrl or false,
                                binding.alt or false,
                                binding.shift or false
                            );

                            if bindKey then
                                table.insert(newBinds, {
                                    key = bindKey,
                                    barIndex = barIndex,
                                    slotIndex = slotIndex,
                                });
                            end
                        end
                    end
                end
            end
        end

        -- Unbind old binds that aren't in the new set
        local newBindSet = {};
        for _, bind in ipairs(newBinds) do
            newBindSet[bind.key] = true;
        end

        for _, bindKey in ipairs(registeredBinds) do
            if not newBindSet[bindKey] then
                chatManager:QueueCommand(-1, '/unbind ' .. bindKey);
            end
        end

        -- Register new binds (overwrites existing binds with same key)
        registeredBinds = {};
        for _, bind in ipairs(newBinds) do
            local bindCommand = string.format(
                '/bind %s /xiui hotbar %d %d',
                bind.key, bind.barIndex, bind.slotIndex
            );
            chatManager:QueueCommand(-1, bindCommand);
            table.insert(registeredBinds, bind.key);
        end
    end);

    if not ok then
        print('[XIUI] Warning: Failed to register keybinds: ' .. tostring(err));
    end
end

--- Unregister all previously registered keybinds (called on addon unload)
--- NOTE: This is intentionally minimal to avoid command queue issues during reload.
--- The binds will either be overwritten by the next load or cleaned up manually.
function M.UnregisterKeybinds()
    -- Set cleanup flag to prevent re-registration during unload
    isCleaningUp = true;

    -- Clear local tracking only
    -- We intentionally DON'T send /unbind commands here because:
    -- 1. During addon reload, commands can interleave unpredictably
    -- 2. The new module will overwrite binds with same keys anyway
    -- 3. Sending many commands during unload can cause instability
    registeredBinds = {};

    -- Reset silent mode tracking so the next load will re-enable it
    silentModeEnabled = false;
end

return M